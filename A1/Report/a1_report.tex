\documentclass[a4 paper]{article}
% Set target color model to RGB
\usepackage[inner=2.0cm,outer=2.0cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{setspace}
\usepackage[rgb]{xcolor}
\usepackage{verbatim}
\usepackage{subcaption}
\usepackage{amsgen,amsmath,amstext,amsbsy,amsopn,tikz,amssymb,tkz-linknodes}
\usepackage{fancyhdr}
\usepackage[colorlinks=true, urlcolor=blue,  linkcolor=blue, citecolor=blue]{hyperref}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{rotating}
\usepackage{algorithm2e}

\usepackage{listings}
\usepackage{color}
\usepackage{graphicx} 

\newcommand{\code}[1]{\texttt{#1}}

\lstset{
  tabsize=2,
  basicstyle=\fontsize{12}{5.5}\ttfamily,
  language=C,
  showspaces=false,
  showtabs=false,
  % numbers = left,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941},
  basicstyle=\ttfamily,
  moredelim=[il][\textcolor{pgrey}]{$$},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}

\usepackage{booktabs}
\input{macros.tex}

\begin{document}
\homework{Assignment 1 Report}{Date: February 24, 2019}{}{\bf 2016CS10363}{\bf Manish Tanwar}{NetId(s)}


\section{System Calls:}

\section{Inter-Process Communication:}
% \subsection*{Unicasting:}
\subsection*{Signal Handling:}

\begin{itemize}

% \raggedbottom\lstinputlisting[language=C]{codes/1.c}
\item \textbf{Signal Handler Function Signature:}
% \par 

\begin{lstlisting}
      typedef void (*sighandler_t)(void*);
\end{lstlisting}

\vspace*{-1.5mm}

\begin{itemize}
\item \texttt{sighandler\_t} is a function pointer which takes a void pointer as argument and returns void.
\end{itemize}

\item \textbf{System Calls for Signal Handling:}

\raggedbottom\lstinputlisting[language=C]{codes/1.c}

\item \textbf{Added Fiedls in Proc Struct:}

\begin{itemize}
  \item Signal Handlers : It stores function pointers to signal handlers for that process, i.e if another process sends this process a signal with \code{sig\_num} then the Signal Handler is implemented which is pointed by the stored function pointer. Pointer is set to 0, if no signal handler is set.
  \item Signal Queue : A queue to store the pending signals for that process. It stores \code{sig\_num} and \code{sig\_arg} for each pending signal. The queue is emplemented using an array with constant size 256 (circular array implementation).

  \begin{lstlisting}
    struct sig_queue
    {
      struct spinlock lock;
      char sig_arg[SIG_QUE_SIZE][MSGSIZE];
      int sig_num_list[SIG_QUE_SIZE];
      int start; // works as channel also
      int end;
    };
  \end{lstlisting}
\end{itemize}

\item \textbf{Setting a Signal Handler:}
\begin{itemize}
  \item Function Signature: \begin{lstlisting}
int sig_set(int sig_num, sighandler_t handler);
  \end{lstlisting}
  \item The system call \code{sig\_set} is called by the receicer to set the signal handler's function pointer.
  \item The system call \code{fork} copies the parent's signal handlers to child's process.
  \item The system call \code{exec} resets the signal handlers to default value 0.
  \item The function \code{allocproc} resets the \code{sig\_queue} to an empty queue.
\end{itemize}

\item \textbf{Sending a Signal:}
\begin{itemize}
  \item Function Signature: \begin{lstlisting}
int sig_send(int dest_pid, int sig_num, void *sig_arg);
  \end{lstlisting}
  \item The sender calls syscall \code{sig\_send} for sending a signal to process with pid \code{dest\_pid}.
  \item The receiver process will implemented it's signal handler indexed with \code{sig\_num} with argument \code{sig\_arg}, only if there is a signal handler set to \code{sig\_num} by the receiver already.
\end{itemize}

\item \textbf{Handling a Signal:}
\begin{itemize}
  \item Whenever a process is about to return from kernel mode to user mode with function call \code{trepret} (implemented in trapasm.S) it checks the signal queue by calling the function \code{execute\_signal\_handler}.
  \item Function \code{execute\_signal\_handler} does the following:
  \begin{itemize}
    \item If there is no signal available for this process then it returns back to \code{trepret}.
    \item \textbf{Setting up user stack:} (for calling the signal handler)
    \begin{enumerate}
      \item For saving the user mode's context it saves the trapframe of this process from the kernel stack to the user mode stack.
      \item It changes the register \code{\%eip} (stored in the trapframe) to the function pointer of the signal handler.
      \item We can push the parameter \code{sig\_arg} on the stack, but this pointer points to a address in kernel space(which can't be accessed by the signal handler which is implemented in the user mode), so we first push 8 bytes of the message on the stack and then we push the pointer to the first byte pushed on to the stack as a pointer.
      \item Returning back to kernel mode is neccesary to retrieve back the user mode context.
      \item For returning back from the user mode to kernel mode, we have to make a syscall \code{sig\_ret} but the signal handler might not call this syscall due to other interrupts. To solve this problem we wrap up the system call code(written in \code{x86} assembly) on the stack and call it implicitly by pushing the return address for signal handler as the wrapped code's first instruction.
      \item Return back to \code{trapret} function to call user mode's signal handler.
    \end{enumerate}
  \end{itemize}

  \item Returing from Signal Handling:
  \begin{itemize}
    \item When the signal handler executes the wrapped code on the stack it calls \code{sig\_ret} syscall.
    \item \code{sig\_ret} syscall just save the trapfram back from user stack to the kernel stack which retrieves back the original user mode context.
  \end{itemize}
\end{itemize}

  \item \textbf{Waiting for a Signal:}
  \begin{itemize}
    \item A process may want to wait for a signal to arrive. 
    \item A process can make \code{sig\_pause} to get blocked until a signal arrives for it.
    \item \code{sig\_pause} checks if there is any signal available for this process, if there is not then it gets blocked by calling function \code{sleep} on a certain channel.
    \item Syscall \code{sig\_send} wakeups the receiver process which might be waiting for a signal. 
  \end{itemize}
\end{itemize}

\subsection*{Multicasting:}


\section{Distributed Algorithm:}

\begin{itemize}
  \item The coordinator(parent) process forks $n$ child process(workers). $n$ is kept equal to 8 but can be scaled further(tested upto $32$). 
  \item Every worker process is assigned equal size subarrays to proceed on (with an exception of the last child process).
  \item Every worker process computes the parital sum of subarray assigned and sends it to the coordinator using unicasting function implemented.
  \item The coordinator collects the parital sums and computes the total sum. Then it multicasts the mean to each worker process.
  \item Every worker process computes the sum of the squares of the differences about the mean and sends to the coordinator using unicasting.
  \item The coordinator collects the partial square sums and computes the variance.
\end{itemize}


\end{document} 